{% extends 'base.html' %}
{% load i18n %}
{% block title %}{% trans 'Regla de Simpson 1/3 simple' %} - {% trans 'Numerical Methods' %}{% endblock %}
{% block content %}
    {% load static %}
    <div class="container-sm p-5">
        <div class="row pb-0 pt-lg-5 align-items-center rounded-3 mb-5 mb-5">
            <div class="col-lg-12">
                <h2 class="display-4 fw-bold lh-1s">{% trans 'Regla de Simpson 1/3 simple' %}</h2>
                {% get_current_language as LANGUAGE_CODE %}
                <p class="lead py-5">
                    {% if LANGUAGE_CODE == "es" %}
                        La regla de Simpson 1/3 simple es un método de integración numérica que aproxima el área bajo una curva usando un polinomio cuadrático. Este método ofrece una mejor aproximación que la regla del trapecio para funciones con curvatura, ya que considera la concavidad de la función.
                    {% else %}
                        Simpson's 1/3 rule is a numerical integration method that approximates the area under a curve using a quadratic polynomial. This method provides better approximation than the trapezoidal rule for curved functions, as it takes into account the concavity of the function.
                    {% endif %}
                </p>
                <div class="d-grid gap-2 d-md-flex justify-content-md-start mb-4 mb-lg-3">
                    <button type="button" class="btn btn-primary btn-lg px-4 me-md-2 fw-bold"
                            onclick="showCalculator()">{% translate 'Calculadora' %}
                    </button>
                    <button type="button" class="btn btn-outline-secondary btn-lg px-4" onclick="showExplanation()">
                        {% translate 'Explanation' %}
                    </button>
                </div>
            </div>
        </div>

        <div class="py-3"></div>

        <!-- Hidden calculator section -->
        <div id="calculator" style="display: none !important;" class="mt-5">
            <h3 class="mb-5">{% translate 'Calculadora de la regla de Simpson de 1/3 simple' %}</h3>
            <div class="mb-5 p-4 bg-light rounded-3 shadow">

                <!-- Header -->
                <div class="btn-toolbar d-flex flex-column">
                    <div class="mb-2">
                        <H4>{% translate 'Intervalo de integración' %}</H4>
                    </div>
                    <div class="d-flex flex-row justify-content-between">
                        <form class="form d-flex align-items-center">
                            <div class="input-group">
                                <span class="input-group-text" id="basic-addon1">a</span>
                                <input id="inputA" type="text" class="form-control" placeholder="{% translate 'Inicio' %}"
                                       aria-label="Username"
                                       aria-describedby="basic-addon1">
                            </div>
                            <span class="fw-bolder" style="margin: 0 10px;">-</span>
                            <div class="input-group">
                                <span class="input-group-text" id="basic-addon1">b</span>
                                <input id="inputB" type="text" class="form-control" placeholder="{% translate 'Fin' %}"
                                       aria-label="Username"
                                       aria-describedby="basic-addon1">
                            </div>
                        </form>
                        <div class="btn-group">
                            <button style="height: fit-content" type="button" class="btn btn-outline-secondary"
                                    id="clearBtn">
                                <i class="bi bi-trash"></i> {% translate 'Limpiar' %}
                            </button>
                            <button style="height: fit-content" type="button" class="btn btn-primary" id="solveBtn">
                                <i class="bi bi-calculator"></i>
                                <span class="spinner-border spinner-border-sm me-2" role="status" style="display: none;"
                                      id="loadingSpinner"></span>
                                <span id="buttonText">{% translate 'Calcular' %}</span>
                            </button>
                        </div>
                    </div>
                </div>

                <div id="alertContainer" class="my-3">
                    <!-- Alerts -->
                </div>
                <!-- Matrix -->
                <div class="card-body">
                    <div class="matrix-container overflow-auto">
                        <div class="d-flex my-4">
                            <div class="matrix-bracket bracket-left">
                                <!-- Corchete izquierdo -->
                            </div>
                            <table id="matrixTable" class="matrix-table">
                                <tbody id="matrixBody">
                                <!-- Aquí se generará la matriz dinámicamente -->
                                </tbody>
                            </table>
                            <div class="matrix-bracket bracket-right">
                                <!-- Corchete derecho -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Container for the results table -->
            <div id="responseContainer" class="mt-5" style="display: none;">
                <!-- Section to show results -->
                <div id="resultContainer" class="mt-5">
                </div>

                <!-- Section to show the steps -->
                <div id="stepsContainer" class="p-4 mt-3 bg-light rounded-3 shadow"></div>
            </div>

        </div>

        <!-- Hidden extensive explanation section -->
        <div id="explanation" class="mt-4 rounded-3 lead" style="display: none !important;">
            <h3 class="pb-3">{% translate "Explicación de la regla de Simpson de 1/3 simple" %}</h3>

            <h4 class="mt-4">{% translate 'Descripción General' %}</h4>
            <p>
                La <strong>regla de Simpson de 1/3 simple</strong> es un método de integración numérica que utiliza
                un único
                polinomio cuadrático para aproximar el área bajo una curva. Es una técnica de interpolación
                polinómica que
                ofrece una manera eficiente de calcular integrales definidas, especialmente cuando la función a
                integrar es
                suave y el intervalo de integración es pequeño.
            </p>

            <h4 class="mt-4">{% translate 'Fundamentos Matemáticos' %}</h4>
            <p>
                Dado un intervalo \([a, b]\) y una función \(f(x)\) que es continua en ese intervalo, la regla de
                Simpson
                de 1/3 simple aproxima la integral definida de la siguiente manera:
                \[
                \int_{a}^{b} f(x) \, dx \approx \frac{(b - a)}{6} \left( f(a) + 4f\left(\frac{a+b}{2}\right) + f(b) \right)
                \]
            </p>

            <h4 class="mt-4">{% translate 'Algoritmo' %}</h4>
            <p>
                Para aplicar la regla de Simpson de 1/3 simple, se siguen estos pasos:
            <ol>
                <li>Se evalúa la función \(f(x)\) en tres puntos: \(a\), \(b\) y el punto medio \(\frac{a+b}{2}\).</li>
                <li>Se aplica la fórmula de la regla de Simpson de 1/3 simple para obtener la aproximación de la
                    integral.
                </li>
            </ol>
            </p>

            <h4 class="mt-4">{% translate 'Ejemplo' %}</h4>
            <p>
                Consideremos la integral:
                \[
                \int_{1}^{3} (x^2 + 2x) \, dx
                \]

                Aplicando la regla de Simpson de 1/3 simple:
                \[
                \begin{align*}
                &\text{Intervalo: } [1, 3] \\
                &\text{Puntos: } 1, 2, 3 \\
                &\text{Valores de la función: } f(1), f(2), f(3) \\
                &\text{Aproximación: } \frac{(3-1)}{6} \left( f(1) + 4f(2) + f(3) \right)
                \end{align*}
                \]
            </p>
        </div>


        <script>
            const points = [];

            function showCalculator() {
                document.getElementById('explanation').style.display = 'none';
                document.getElementById('calculator').style.display = 'block';
            }

            function showExplanation() {
                document.getElementById('calculator').style.display = 'none';
                document.getElementById('explanation').style.display = 'block';
            }

            // Matrix buttons
            const aInput = document.getElementById('inputA');
            const bInput = document.getElementById('inputB');
            const matrixBody = document.getElementById('matrixBody');
            const solveBtn = document.getElementById('solveBtn');
            const responseContainer = document.getElementById('responseContainer');
            const resultContainer = document.getElementById('resultContainer');
            const clearBtn = document.getElementById('clearBtn');

            // Generate Matrix Function
            function generateMatrix() {
                const a = parseFloat(aInput.value);
                const b = parseFloat(bInput.value);

                // Validaciones
                if (isNaN(a) || isNaN(b) || a >= b) {
                    showAlert('Por favor, ingresa valores válidos para el intervalo', 'warning');
                    return;
                }

                // Limpiar la matriz actual
                matrixBody.innerHTML = '';

                // Generar filas y columnas de la matriz
                const row = document.createElement('tr');

                for (let j = 0; j < 3; j++) {
                    const cell = document.createElement('td');

                    // Crear un grupo de input con texto
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'input-group';

                    // Input para el valor
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.step = 'any'; // Permite decimales
                    input.className = 'form-control matrix-input';
                    input.dataset.row = 0;
                    input.dataset.col = j;

                    // Etiqueta para la variable
                    const varLabel = document.createElement('span');
                    varLabel.className = 'input-group-text';

                    // Asignar la etiqueta adecuada dependiendo de la columna
                    if (j === 0) {
                        // Columna a
                        varLabel.textContent = 'a';
                        varLabel.title = 'Límite inferior de integración';
                    } else if (j === 1) {
                        // Columna b
                        varLabel.textContent = 'b';
                        varLabel.title = 'Límite superior de integración';
                    } else {
                        // Columna del término independiente
                        varLabel.textContent = 'f(a)';
                        varLabel.title = 'Valor de la función en a';
                    }

                    // Añadir elementos al grupo
                    inputGroup.appendChild(varLabel);
                    inputGroup.appendChild(input);

                    cell.appendChild(inputGroup);
                    row.appendChild(cell);
                }

                matrixBody.appendChild(row);

                // Mostrar el contenedor de la matriz
                document.getElementById('calculator').style.display = 'block';
            }

            // Evento para generar la matriz cuando se cambian los valores de a y b
            aInput.addEventListener('change', generateMatrix);
            bInput.addEventListener('change', generateMatrix);

            // Evento para limpiar la matriz
            clearBtn.addEventListener('click', function () {
                const inputs = document.querySelectorAll('.matrix-input');
                inputs.forEach(input => {
                    input.value = '';
                });
            });

            // Evento para resolver el sistema
            solveBtn.addEventListener('click', function () {
                // Limpiar alertas anteriores
                const alertContainer = document.getElementById('alertContainer');
                if (alertContainer) {
                    alertContainer.innerHTML = '';
                }

                const a = parseFloat(aInput.value);
                const b = parseFloat(bInput.value);

                // Validaciones
                if (isNaN(a) || isNaN(b) || a >= b) {
                    showAlert('Por favor, ingresa un intervalo válido (a < b)', 'warning');
                    return;
                }

                // Crear matriz para almacenar los valores
                const matrix = [[a, b]];

                // Mostrar mensaje de éxito
                showAlert('Intervalo cargado correctamente.', 'success');

                // Llamar a la función que calcula la regla de Simpson
                calculate();

                // Mostrar el contenedor de respuesta
                document.getElementById('responseContainer').style.display = 'block';
            });

            // Generar la matriz inicial al cargar la página
            document.addEventListener('DOMContentLoaded', function () {
                const calculatorSection = document.getElementById('calculator');
                const explanationSection = document.getElementById('explanation');

                calculatorSection.style.display = 'none';
                explanationSection.style.display = 'block';

                window.showCalculator = function () {
                    explanationSection.style.display = 'none';
                    calculatorSection.style.display = 'block';
                };

                window.showExplanation = function () {
                    calculatorSection.style.display = 'none';
                    explanationSection.style.display = 'block';
                };

                generateMatrix();

                setTimeout(function () {
                    calculatorSection.style.display = 'none';
                    explanationSection.style.display = 'block';
                }, 100);
            });

            // Agregar estilos prioritarios inmediatamente
            (function () {
                const style = document.createElement('style');
                style.textContent = `
        #calculator { display: none !important; }
        #explanation { display: block !important; }
    `;
                document.head.appendChild(style);

                setTimeout(function () {
                    document.head.removeChild(style);
                }, 1000);
            })();

            function setLoadingState(isLoading) {
                const button = document.getElementById("solveBtn");
                const spinner = document.getElementById("loadingSpinner");
                const buttonText = document.getElementById("buttonText");

                button.disabled = isLoading;
                spinner.style.display = isLoading ? "inline-block" : "none";
                buttonText.textContent = isLoading ? "{% translate 'Calculando...' %}" : "{% translate 'Calcular' %}";
            }

            function showAlert(message, type = 'danger') {
                // Buscar o crear el contenedor de alertas
                let alertContainer = document.getElementById('alertContainer');

                // Si no existe el contenedor, lo creamos
                if (!alertContainer) {
                    alertContainer = document.createElement('div');
                    alertContainer.id = 'alertContainer';
                    alertContainer.className = 'my-3';

                    // Insertar el contenedor después del toolbar
                    const toolbar = document.querySelector('.btn-toolbar');
                    toolbar.parentNode.insertBefore(alertContainer, toolbar.nextSibling);
                }

                // Limpiar alertas anteriores
                alertContainer.innerHTML = '';

                // Crear la alerta simple
                const alertDiv = document.createElement('div');
                alertDiv.className = `alert alert-${type}`;
                alertDiv.role = 'alert';

                // Agregar el mensaje
                alertDiv.textContent = message;

                // Agregar la alerta al contenedor
                alertContainer.appendChild(alertDiv);
            }

            function getCSRFToken() {
                // Buscar el token CSRF en las cookies
                const cookies = document.cookie.split(';');
                for (let cookie of cookies) {
                    const [name, value] = cookie.trim().split('=');
                    if (name === 'csrftoken') {
                        return value;
                    }
                }

                // Alternativamente, buscar el token en el input del formulario
                const tokenInput = document.querySelector('input[name="csrfmiddlewaretoken"]');
                if (tokenInput) {
                    return tokenInput.value;
                }

                return '';
            }

            // 1. Corrigamos el problema principal con path incorrectos
            function calculate() {
                setLoadingState(true);

                const a = parseFloat(aInput.value);
                const b = parseFloat(bInput.value);

                // Validaciones
                if (isNaN(a) || isNaN(b) || a >= b) {
                    showAlert('Por favor, ingresa un intervalo válido (a < b)', 'warning');
                    setLoadingState(false);
                    return;
                }

                const matrix = [[a, b]];

                // Asegurarse de que la URL es correcta - puede necesitar ajustarse según la configuración de tu proyecto
                fetch('/calculate-simpson-1-3-simple/', {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": getCSRFToken(),
                    },
                    body: JSON.stringify({matrix: matrix}),
                })
                    .then(response => {
                        if (!response.ok) {
                            if (response.status === 400) {
                                return response.json().then(data => {
                                    throw new Error(data.error || 'Error en la solicitud');
                                });
                            }
                            throw new Error('Error en la comunicación con el servidor. Código: ' + response.status);
                        }
                        return response.json();
                    })
                    .then(data => {
                        // Mostrar los pasos del proceso siempre
                        if (data.process_steps) {
                            showProcessSteps(data.process_steps);
                        }

                        // Mostrar el resultado según el tipo de solución
                        showResultBasedOnStatus(data);
                    })
                    .catch(error => {
                        console.error("Error:", error);
                        showAlert(`Error: ${error.message}`, 'danger');
                    })
                    .finally(() => {
                        setLoadingState(false);
                    });
            }

            // 2. Mejora en la función showProcessSteps para evitar errores de DOM
            function showProcessSteps(steps) {
                if (!steps || steps.length === 0) {
                    return;
                }

                const stepsContainer = document.getElementById("stepsContainer");
                // Limpiar el contenedor
                stepsContainer.innerHTML = "<h4>Desarrollo del proceso:</h4>";

                steps.forEach((stepObj, index) => {
                    let stepContent = "";
                    let stepTitle = `<strong>Paso ${index + 1}:</strong> ${stepObj.step || ''}`;

                    // Para matrices aumentadas [A|b]
                    if (stepObj.matrix) {
                        try {
                            const latexMatrix = formatMatrixToLatex(stepObj.matrix, 4);
                            stepContent += `<p>$$${latexMatrix}$$</p>`;
                        } catch (e) {
                            console.error("Error al formatear matriz:", e);
                            stepContent += `<p class="text-danger">Error al formatear matriz</p>`;
                        }
                    }

                    // Para matrices L y L^T
                    if (stepObj.L && stepObj.LT) {
                        try {
                            const latexL = formatMatrixToLatex(stepObj.L, 4, false);
                            const latexLT = formatMatrixToLatex(stepObj.LT, 4, false);

                            stepContent += `<p>Matriz L (triangular inferior):</p>
                              <p>$$${latexL}$$</p>
                              <p>Matriz L^T (triangular superior):</p>
                              <p>$$${latexLT}$$</p>`;
                        } catch (e) {
                            console.error("Error al formatear matrices L y LT:", e);
                            stepContent += `<p class="text-danger">Error al formatear matrices de factorización</p>`;
                        }
                    }

                    // Para verificación A = L*L^T
                    if (stepObj.A && stepObj.LLT) {
                        try {
                            const latexA = formatMatrixToLatex(stepObj.A, 4, false);
                            const latexLLT = formatMatrixToLatex(stepObj.LLT, 4, false);

                            stepContent += `<p>Matriz A original:</p>
                              <p>$$${latexA}$$</p>
                              <p>Matriz L*L^T calculada:</p>
                              <p>$$${latexLLT}$$</p>`;

                            if (stepObj.is_valid !== undefined) {
                                stepContent += `<p class="${stepObj.is_valid ? 'text-success' : 'text-danger'}">
                                  <strong>Factorización ${stepObj.is_valid ? 'válida' : 'no válida'}</strong>
                                  </p>`;
                            }
                        } catch (e) {
                            console.error("Error al formatear matrices de verificación:", e);
                            stepContent += `<p class="text-danger">Error al formatear matrices de verificación</p>`;
                        }
                    }

                    // Para el sistema Ly = b
                    if (stepObj.L && stepObj.b && stepObj.y) {
                        try {
                            const latexL = formatMatrixToLatex(stepObj.L, 4, false);
                            const latexB = formatVectorToLatex(stepObj.b, 4);
                            const latexY = formatVectorToLatex(stepObj.y, 4);

                            stepContent += `<p>Resolviendo Ly = b:</p>
                              <p>$$${latexL} \\cdot ${latexY} = ${latexB}$$</p>`;
                        } catch (e) {
                            console.error("Error al formatear sistema Ly=b:", e);
                            stepContent += `<p class="text-danger">Error al formatear sistema de ecuaciones</p>`;
                        }
                    }

                    // Para el sistema L^T x = y
                    if (stepObj.LT && stepObj.y && stepObj.x) {
                        try {
                            const latexLT = formatMatrixToLatex(stepObj.LT, 4, false);
                            const latexY = formatVectorToLatex(stepObj.y, 4);
                            const latexX = formatVectorToLatex(stepObj.x, 4);

                            stepContent += `<p>Resolviendo L^T x = y:</p>
                              <p>$$${latexLT} \\cdot ${latexX} = ${latexY}$$</p>`;
                        } catch (e) {
                            console.error("Error al formatear sistema L^Tx=y:", e);
                            stepContent += `<p class="text-danger">Error al formatear sistema de ecuaciones</p>`;
                        }
                    }

                    // Para la solución final
                    if (stepObj.solution) {
                        try {
                            const formattedSolution = stepObj.solution.map((val, i) => `x_{${i + 1}} = ${val.toFixed(4)}`).join(", ");
                            stepContent += `<p><strong>Solución final:</strong> $$${formattedSolution}$$</p>`;
                        } catch (e) {
                            console.error("Error al formatear solución final:", e);
                            stepContent += `<p class="text-danger">Error al formatear la solución final</p>`;
                        }
                    }

                    // Para información de análisis de rango
                    if (stepObj.rank !== undefined) {
                        stepContent += `<p><strong>Rango de la matriz:</strong> ${stepObj.rank}</p>`;
                        if (stepObj.variables !== undefined) {
                            stepContent += `<p><strong>Número de variables:</strong> ${stepObj.variables}</p>`;
                        }
                        if (stepObj.free_variables !== undefined && Array.isArray(stepObj.free_variables)) {
                            stepContent += `<p><strong>Variables libres:</strong> ${stepObj.free_variables.join(', ')}</p>`;
                        }
                        if (stepObj.description !== undefined) {
                            stepContent += `<p><strong>${stepObj.description}</strong></p>`;
                        }
                    }

                    const stepElement = document.createElement("div");
                    stepElement.innerHTML = `
            <div style="border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; border-radius: 5px;">
                ${stepTitle}
                ${stepContent}
            </div>
        `;

                    stepsContainer.appendChild(stepElement);
                });

                // Re-renderizar el contenido LaTeX usando MathJax
                setTimeout(() => {
                    if (typeof MathJax !== 'undefined') {
                        try {
                            MathJax.typeset();
                        } catch (e) {
                            console.error("Error al procesar MathJax:", e);
                        }
                    } else {
                        console.warn("MathJax no está disponible. Las fórmulas matemáticas no se renderizarán correctamente.");
                    }
                }, 100);
            }

            function showResultBasedOnStatus(data) {
                const responseContainer = document.getElementById("responseContainer");
                responseContainer.style.display = "block";

                const resultContainer = document.getElementById("resultContainer");

                // Determinar el tipo de resultado y mostrar el mensaje apropiado
                if (data.status === "success") {
                    // Sistema con solución única
                    let solutionHTML = "<ul class='list-group list-group-flush'>";
                    for (let i = 0; i < data.solution.length; i++) {
                        solutionHTML += `<li class="list-group-item">x${i + 1} = ${data.solution[i].toFixed(4)}</li>`;
                    }
                    solutionHTML += "</ul>";

                    resultContainer.innerHTML = `
                        <div class="alert alert-success" role="alert">
                        <h4>{% translate 'Solution of the equation' %}:</h4>
                        ${solutionHTML}
                        </div>
                    `;
                } else if (data.status === "error") {
                    // Sistema sin solución o error
                    resultContainer.innerHTML = `
                        <div class="alert alert-danger" role="alert">
                        <h4>{% translate 'Error' %}:</h4>
                        <p>${data.message}</p>
                        </div>
                    `;
                } else if (data.status === "infinite_solutions") {
                    // Sistema con infinitas soluciones
                    let detailsHTML = "";
                    if (data.details) {
                        detailsHTML = `
                            <p>Rango de la matriz: ${data.details.rank}</p>
                            <p>Número de variables: ${data.details.variables}</p>
                            <p>Variables libres: ${data.details.free_variables.join(', ')}</p>
                            <p>${data.details.description}</p>
                        `;
                    }

                    resultContainer.innerHTML = `
                        <div class="alert alert-warning" role="alert">
                        <h4>{% translate 'Infinite solutions' %}:</h4>
                        <p>${data.message}</p>
                        ${detailsHTML}
                        </div>
                    `;
                } else {
                    // Estado desconocido, mostrar información general
                    resultContainer.innerHTML = `
                        <div class="alert alert-info" role="alert">
                        <h4>Resultado del cálculo:</h4>
                        <pre>${JSON.stringify(data, null, 2)}</pre>
                        </div>
                    `;
                }
            }

            // 3. Funciones de formato mejoradas
            function formatMatrixToLatex(matrix, decimals = 4, augmented = true) {
                if (!matrix || matrix.length === 0) {
                    return "\\text{Empty matrix}";
                }

                try {
                    const numCols = matrix[0].length;
                    // Crear formato de columnas con una línea vertical antes de la última columna si es matriz aumentada
                    let columnFormat = "";
                    for (let i = 0; i < numCols; i++) {
                        columnFormat += "c";
                        // Añade la línea vertical antes de la última columna solo si es matriz aumentada
                        if (augmented && i === numCols - 2) {
                            columnFormat += "|";
                        }
                    }

                    const rows = matrix.map(row => {
                        return row.map(val => {
                            if (typeof val === 'number') {
                                // Formatear el número para evitar problemas con valores muy pequeños o NaN
                                if (isNaN(val)) return "?";
                                if (Math.abs(val) < 1e-10) return "0";
                                return val.toFixed(decimals);
                            }
                            return val;
                        }).join(" & ");
                    }).join(" \\\\ ");

                    return "\\left[ \\begin{array}{" + columnFormat + "} " + rows + " \\end{array} \\right]";
                } catch (e) {
                    console.error("Error en formatMatrixToLatex:", e);
                    return "\\text{Error al formatear matriz}";
                }
            }

            function formatVectorToLatex(vector, decimals = 4) {
                if (!vector || vector.length === 0) {
                    return "\\text{Empty vector}";
                }

                try {
                    const elements = vector.map(val => {
                        if (typeof val === 'number') {
                            // Formatear el número para evitar problemas con valores muy pequeños o NaN
                            if (isNaN(val)) return "?";
                            if (Math.abs(val) < 1e-10) return "0";
                            return val.toFixed(decimals);
                        }
                        return val;
                    }).join(" \\\\ ");

                    return "\\begin{bmatrix} " + elements + " \\end{bmatrix}";
                } catch (e) {
                    console.error("Error en formatVectorToLatex:", e);
                    return "\\text{Error al formatear vector}";
                }
            }
        </script>

    </div>


{% endblock %}